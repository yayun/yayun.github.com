---
layout: post
title: "MIT 6.824 Lab2 ç¬”è®°"
---

MIT6.824 lab2 åˆ†ä¸º 3 ä¸ª task: 2A éœ€è¦å®ç° leader é€‰ä¸¾å’Œ heartbeatï¼ˆappendEntries ä¸æ¶‰åŠ log entriesï¼‰; 2B éœ€è¦å®ç°æ¶‰åŠæ—¥å¿—å¤åˆ¶çš„é—®é¢˜ï¼›2C å®ç°æŒä¹…åŒ–è®¾è®¡çš„éƒ¨åˆ†ã€‚

æ€»ä¹‹ï¼Œè°ƒ bug è°ƒåˆ°æ€€ç–‘äººç”Ÿ ğŸ¤¦â€â™€ï¸...

å€Ÿç”¨ mit6.824 è¯¾ç¨‹ä¸­åŠ©æ•™çš„ä¸€æ®µè¯ï¼Œä¸å›å…±å‹‰ï¼šFocus on how to write correct code, dont't focus way too much on the happens before relation and being able to reason about exactly why incorrect code is't correct like we done't really care, we just want to be able to write correct code and call it a day.

Raft ä¸€å…±åªæœ‰ä¸¤ä¸ªæ¥å£ï¼šAppendEntries å’Œ RequestVoteã€‚å¬èµ·æ¥å¾ˆç®€å•ï¼Œä½†æ˜¯é‡Œé¢çš„ç»†èŠ‚éå¸¸å¤šã€‚ä¸€å®šè¦ä»”ç»†çœ‹è®ºæ–‡ï¼ˆå°¤å…¶æ˜¯è®ºæ–‡ä¸­çš„ figure2ï¼‰å’Œ student's guideã€‚

### Raft æ•°æ®ç»“æ„

	type Raft struct {
		mu        sync.Mutex          // Lock to protect shared access to this peer's state
		peers     []*labrpc.ClientEnd // RPC end points of all peers
		persister *Persister          // Object to hold this peer's persisted state
		me        int                 // this peer's index into peers[]
		dead      int32               // set by Kill()

		votedFor int // å½“å‰ä»»æœŸå†…æŠ•ç»™äº†è°

		// Persistent state on all servers
		currentTerm int
		logEntries  []logEntry // log entries; each entry contains command for state machine, and term when entry was received by leader (first index is 1)

		// Volatile state on all servers
		commitIndex int // index of highest log entry known to be committed
		lastApplied int // index of highest log entry applied to state machine

		// Volatile state on leaders
		nextIndex  []int // for each server, index of the next log entry to send to that server (initialized to leader last log index + 1)
		matchIndex []int // for each server, index of highest log entry known to be replicated on server (initialized to 0, increases monotonically)

		currentRole            int              // å½“å‰ server çš„èº«ä»½
		votes                  map[int]bool // é€‰ä¸¾çš„å¾—ç¥¨æ•°
		electionTimeout        int32            // é€‰ä¸¾è¶…æ—¶æ—¶é—´
		heartbeatTimestamp     int32            // æ”¶åˆ°å¿ƒè·³çš„æ—¶é—´
		lastHeartbeatTimestamp int32            // ä¸Šæ¬¡å‘å‡ºå¿ƒè·³çš„æ—¶é—´
		applyCh chan ApplyMsg
	}
	
### Leader é€‰ä¸¾
Make å‡½æ•°åˆ›å»º raft serverï¼Œè®¾ç½® electionTimeout å’Œ å¿ƒè·³æ—¶é—´ï¼Œ electionTimeout éšæœºï¼Œç›®å‰æˆ‘è®¾ç½®çš„æ˜¯ 300msï½400msã€‚`raftServer()` , æ¯éš” `DefaultIntervalMs` æ£€æµ‹å½“å‰èŠ‚ç‚¹ï¼Œæ˜¯å¦è¦å‘èµ·é€‰ä¸¾ï¼ˆfollower or candidateï¼‰ï¼Œæ˜¯å¦è¦å‘èµ· appendEntriesï¼ˆleaderï¼‰ã€‚DefaultIntervalMs æˆ‘è®¾ç½®äº† 10msã€‚

	func Make(peers []*labrpc.ClientEnd, me int,
	persister *Persister, applyCh chan ApplyMsg) *Raft {
		rf := &Raft{}
		rf.peers = peers
		rf.persister = persister
		rf.me = me
		rf.currentRole = Follower
		rf.electionTimeout = rf.getElectionTimeout()
		rf.heartbeatTimestamp = int32(time.Now().UnixNano() / 1e6)
		rf.lastHeartbeatTimestamp = 0
		rf.lastApplied = 0
		rf.commitIndex = 0
		rf.applyCh = applyCh
		rf.votedFor = -1
	
		// Your initialization code here (2A, 2B, 2C).
		// create a goroutine
		go rf.raftServer()
		// initialize from state persisted before a crash
		rf.readPersist(persister.ReadRaftState())
		return rf
	}
	
å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯ candidate æˆ–è€… follower å¹¶ä¸”ä¸Šæ¬¡æ”¶åˆ°å¿ƒè·³çš„æ—¶é—´ï¼ˆheartbeatTimestampï¼‰è·ç¦»ç°åœ¨è¶…è¿‡äº† electionTimeout åˆ™å‘èµ·é€‰ä¸¾ã€‚å¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯ leader å¹¶ä¸”ä¸Šæ¬¡å¿ƒè·³æ—¶é—´è·ç¦»ç°åœ¨è¶…è¿‡ DefaultHeartbeatIntervalMs ï¼ˆæˆ‘è®¾ç½®çš„æ˜¯ 100msï¼‰åˆ™å‘é€ appendEntries RPCã€‚

	func (rf *Raft) raftServer() {
		for {
			if rf.canStartElection() {
				rf.startSelection()
				rf.persist()
			}
			if rf.canSendHeartbeat() {
				rf.sendHeartbeat()
			}
			time.Sleep(DefaultIntervalMs * time.Millisecond)
		}
	}

**å‘èµ·é€‰ä¸¾**ï¼š

1. å°†è‡ªå·±çš„èº«ä»½åˆ‡æ¢æˆ candidate
2. å½“å‰ term++ï¼Œç»™è‡ªå·±æŠ•ä¸€ç¥¨
3. resetElectionTimer
4. åŒæ—¶å¾€å…¶ä»–èŠ‚ç‚¹å‘èµ·æŠ•ç¥¨è¯·æ±‚ã€‚

å‘èµ·é€‰ä¸¾ç›¸å…³ä»£ç ï¼š

	// å‘èµ·æŠ•ç¥¨
	func (rf *Raft) startSelection() {
		lastLogIndex, lastLogTerm := rf.getLastLogIndexAndTerm()
		rf.mu.Lock()
		rf.currentRole = Candidate
		rf.votes = make(map[int]bool)
		rf.votes[rf.me] = true
		rf.currentTerm ++
		rf.votedFor = rf.me
		candidateId := rf.me
		currentRole := rf.currentRole
		peers := rf.peers
		currentTerm := rf.currentTerm
		me := rf.me
		rf.mu.Unlock()
		rf.resetElectionTimer()
		for server, _ := range peers {
			if server == candidateId || currentRole != Candidate {
				continue
			}
			reply := &RequestVoteReply{}
			args := &RequestVoteArgs{
				Term: currentTerm,
				CandidateId: me,
				LastLogIndex: lastLogIndex,
				LastLogTerm: lastLogTerm,
			}
			go rf.sendRequestVote(server, args, reply, peers)
		}
	}	


<img src="/images/requestVote.png">

å‘èµ·æŠ•ç¥¨ä¹‹åæ¯æ”¶åˆ°æŠ•ç¥¨å“åº”éƒ½åˆ¤æ–­ä¸‹å¯¹æ–¹èŠ‚ç‚¹æ˜¯å¦æŠ•ç¥¨ç»™è‡ªå·±ï¼Œå¦‚æœå¾—åˆ°é€‰ç¥¨åˆ¤æ–­ä¸‹æ˜¯å¦å¾—åˆ°å¤§å¤šæ•°çš„é€‰ç¥¨ï¼Œå¦‚æœæ”¶åˆ°å¤§å¤šæ•°çš„é€‰ç¥¨åˆ™ becomeLeaderã€‚

	func (rf *Raft) sendRequestVote(server int, args * RequestVoteArgs, reply *RequestVoteReply, peers []*labrpc.ClientEnd) {
		peer := peers[server]
		ok := peer.Call("Raft.RequestVote", args, reply)
		if !ok {
			return
		}
		rf.convertToFollowerOrNot(reply.Term, server)
		rf.mu.Lock()
		currentRole := rf.currentRole
		rf.mu.Unlock()
		if currentRole == Follower {
			return
		}
		if reply.VoteGranted {
			rf.mu.Lock()
			rf.votes[server] = true
			votes := rf.votes
			rf.mu.Unlock()
			if len(votes) >= rf.majorityCount() && currentRole != Leader {
				rf.becomeLeader()
			}
		}
	}

èŠ‚ç‚¹æ”¶åˆ° candidate çš„æŠ•ç¥¨è¯·æ±‚

1. Reply false if term < currentTerm
2. If votedFor is null or candidateId, and candidateâ€™s log is at least as up-to-date as receiverâ€™s log, grant vote 

1.å¦‚æœ term < currentTerm ç›´æ¥è¿”å›å¤±è´¥ï¼›2. å¦‚æœå½“å‰ term ï¼ˆcandidate å‘è¿‡æ¥çš„å‚æ•°ï¼‰ä¸‹å·²ç»ç»™å…¶ä»–èŠ‚ç‚¹æŠ•ç¥¨è¿”å›å¤±è´¥ï¼›å¦‚æœå½“å‰ term ä¸‹æ²¡æœ‰ç»™å…¶ä»–èŠ‚ç‚¹æŠ•è¿‡ç¥¨æˆ–è€…å·²ç»ç»™å½“å‰ candidate æŠ•è¿‡ç¥¨ï¼Œåˆ™åˆ¤æ–­ candidate çš„æ—¥å¿—ï¼š
a. candidate æœ€åä¸€æ¡æ—¥å¿—çš„ term å¦‚æœå¤§äºè‡ªå·±æœ€åä¸€æ¡æ—¥å¿—çš„ term åˆ™è¿”å›æˆåŠŸï¼›
b. candidate æœ€åä¸€æ¡æ—¥å¿—çš„ term å’Œè‡ªå·±æœ€åä¸€æ¡æ—¥å¿—çš„ term ä¸€æ ·å¤§æƒ…å†µï¼Œæ¯”è¾ƒæœ€åä¸€æ¡æ—¥å¿—çš„ index å¦‚æœ candidate æœ€åä¸€æ¡æ—¥å¿—çš„ index å¤§äºè‡ªå·±æœ€åä¸€æ¡æ—¥å¿—çš„ index åˆ™è¿”å›æˆåŠŸã€‚

RequestVote handler


	func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) {
		rf.convertToFollowerOrNot(args.Term, args.CandidateId)
		lastLogIndex, lastLogTerm := rf.getLastLogIndexAndTerm()
		rf.mu.Lock()
		reply.Term = rf.currentTerm
		reply.VoteGranted = false
		if args.Term < rf.currentTerm {
			reply.VoteGranted = false
		} else if rf.votedFor >= 0 && rf.votedFor != args.CandidateId && rf.currentTerm == args.Term {
			reply.VoteGranted = false
		} else if rf.votedFor < 0 || (rf.votedFor == args.CandidateId && rf.currentTerm == args.Term) || rf.currentTerm != args.Term {
			if args.LastLogTerm > lastLogTerm || (args.LastLogTerm == lastLogTerm && args.LastLogIndex >= lastLogIndex) {
				reply.VoteGranted = true
				rf.votedFor = args.CandidateId
			}
		}
		rf.mu.Unlock()
		if reply.VoteGranted {
			rf.persist()
			rf.resetElectionTimer()
		}
	}
	

Candidate æˆä¸º leader ä¹‹åè¦å¾€å…¶ä»–å€™é€‰äººå‘é€å¿ƒè·³ï¼Œæ¥å®£ç¤ºè‡ªå·±çš„é¢†å¯¼åœ°ä½ã€‚

	func (rf * Raft) sendHeartbeat() {
		rf.mu.Lock()
		me := rf.me
		peers := rf.peers
		currentRole := rf.currentRole
		currentTerm := rf.currentTerm
		commitIndex := rf.commitIndex
		rf.lastHeartbeatTimestamp = rf.getCurrentMillTimeStamp()
		rf.mu.Unlock()
		for server, _ := range peers {
			if server == me || currentRole != Leader {
				continue
			}
			args := &AppendEntriesArgs{
				Term: currentTerm,
				LeaderId: me,
				LeaderCommit: commitIndex,
			}
			args.Entries, args.PrevLogIndex, args.PrevLogTerm = rf.getAppendEntriesArgsByServer(server)
			reply := &AppendEntriesReply{}
			go rf.appendEntries(server, args, reply)
		}

### æ—¥å¿—å¤åˆ¶

leader åœ¨æ”¶åˆ°æ—¥å¿—åä¼šå…ˆæŠŠæ—¥å¿—å†™åˆ°æœ¬åœ°çš„ logEntries é‡Œé¢ã€‚

	func (rf *Raft) Start(command interface{}) (int, int, bool) {
		index := -1
		term := -1
		isLeader := true

		// Your code here (2B).
		_, isLeader = rf.GetState()
		if !isLeader {
			return index, term, false
		}
		index, term = rf.handleLogs(command)
		rf.persist()
		return index, term, isLeader
	}
	
	func (rf *Raft) handleLogs(command interface{}) (int, int){
		rf.mu.Lock()
		log := logEntry {
			Term: rf.currentTerm,
			Command: command,
		}
		rf.logEntries = append(rf.logEntries, log)
		me := rf.me
		lastLogIndex := len(rf.logEntries)
		currentTerm := rf.currentTerm
		rf.mu.Unlock()
		rf.updateNextIndexAndMatchIndex(me, lastLogIndex)
		return lastLogIndex, currentTerm
		}

Leader ä¼šä¸æ–­çš„å¿ƒè·³é¡ºå¸¦å°†è‡ªå·±çš„æ—¥å¿—åŒæ­¥ç»™ followersã€‚
	
AppendEntries RPC

<img src="/images/appendEntries.png">

AppendEntries handler

	func (rf *Raft) AppendEntriesHandler(args *AppendEntriesArgs, reply *AppendEntriesReply) {
		rf.convertToFollowerOrNot(args.Term, args.LeaderId)
		rf.mu.Lock()
		reply.Term = rf.currentTerm
		if args.Term < rf.currentTerm {
			reply.Success = false
			rf.mu.Unlock()
			return
		}
		canSavePersistData = false
		reply.Success = true
		if args.PrevLogIndex > len(rf.logEntries) {
			reply.Success = false
			reply.ConflictIndex = len(rf.logEntries) + 1
			reply.ConflictTerm = -1
		} else if args.PrevLogIndex > 0 && rf.logEntries[args.PrevLogIndex - 1].Term != args.PrevLogTerm {
			reply.Success = false
			reply.ConflictTerm = rf.logEntries[args.PrevLogIndex - 1].Term
			for index, log := range rf.logEntries {
				if log.Term == reply.ConflictTerm {
					reply.ConflictIndex = index + 1
					break
				}
			}
			reply.ConflictTerm = -1
			rf.logEntries = rf.logEntries[:args.PrevLogIndex-1]
			canSavePersistData = true
		} else if args.PrevLogIndex == 0 {
			rf.logEntries = args.Entries
			canSavePersistData = true
		} else if rf.logEntries[args.PrevLogIndex-1].Term == args.PrevLogTerm && len(args.Entries) != 0 {
			rf.logEntries = append(rf.logEntries[:args.PrevLogIndex], args.Entries...)
			canSavePersistData = true
		}
		if reply.Success {
			index := int(math.Min(float64(args.LeaderCommit), float64(len(rf.logEntries))))
			if index > rf.commitIndex {
				rf.commitIndex = index
			}
		}
		rf.mu.Unlock()
		rf.resetElectionTimer()
		// è™½ç„¶æ²¡æœ‰æˆåŠŸ æ—¥å¿—æœ‰å¯èƒ½å·²ç»è¢«åˆ é™¤
		if canSavePersistData {
			rf.persist()
		}
		if reply.Success {
			rf.applyMsg()
		}	
	}

åœ¨å†™ä»£ç çš„æ—¶å€™æ›¾ç»çº ç»“ä¸€ä¸ªé—®é¢˜ï¼šfollower æœ‰å¯èƒ½ä¼šå…ˆæ”¶åˆ° leader å‘æ¥ä¸€æ¡æ¯”è¾ƒé•¿çš„æ—¥å¿—æ¥ç€æ”¶åˆ°ä¸€æ¡ç›¸å¯¹æ¯”è¾ƒçŸ­çš„æ—¥å¿—ï¼Œè¿™æ · follower çš„æ—¥å¿—æœ‰å¯èƒ½å…ˆå˜é•¿æ¥ç€åˆå˜çŸ­ã€‚è¿™æ ·å…¶å®æ²¡é—®é¢˜ï¼Œå› ä¸ºèŠ‚ç‚¹çš„ commitIndex increases
monotonicallyï¼Œå°±ç®—æ—¥å¿—å˜çŸ­ï¼Œleader æ”¶åˆ° follower çš„æ—¥å¿—ä¹‹åä¼šæ ¹æ® prevLogIndex + len(args.logEntries) æ¥æ›´æ–° follower çš„ matchIndexï¼Œè¿™æ · follower çš„æ—¥å¿—è¿˜æ˜¯ä¼šæœ€ç»ˆä¸€è‡´èµ·æ¥çš„ã€‚

â€œFor All serversï¼Œ If commitIndex > lastApplied: increment lastApplied, apply log[lastApplied] to state machineâ€ã€‚appendEntries handler / appendEntries æ”¶åˆ° follower çš„è¿”å› commitIndex å¯èƒ½å‘ç”Ÿäº†å˜åŒ–ï¼Œ è¿™ä¸¤å¤„éƒ½éœ€è¦è°ƒç”¨`applyMsg()` å‡½æ•°ï¼š

	func (rf *Raft) applyMsg() {
		rf.mu.Lock()
		for rf.commitIndex > rf.lastApplied {
			rf.lastApplied ++
			msg := ApplyMsg{
				CommandValid: true,
				Command: rf.logEntries[rf.lastApplied-1].Command,
				CommandIndex: rf.lastApplied,
			}
			rf.applyCh <- msg
		}
		rf.mu.Unlock()
	}

AppendEntries å‡½æ•°
	
	func (rf *Raft) appendEntries(server int, args *AppendEntriesArgs, reply *AppendEntriesReply) {
		rf.mu.Lock()
		peer := rf.peers[server]
		rf.mu.Unlock()
		ok := peer.Call("Raft.AppendEntriesHandler", args, reply)
		if !ok {
			return
		}
		rf.convertToFollowerOrNot(reply.Term, server)
		rf.mu.Lock()
		currentRole := rf.currentRole
		rf.mu.Unlock()
		if currentRole != Leader {
			return
		}
		if reply.Success {
			if len(args.Entries) == 0 {
				return
			}
			rf.updateNextIndexAndMatchIndex(server, args.PrevLogIndex + len(args.Entries))
			rf.updateLeaderCommitIndex()
			rf.applyMsg()
			return
		}
		rf.mu.Lock()
		rf.nextIndex[server] = reply.ConflictIndex
	if reply.ConflictTerm > 0 {
		for i := len(rf.logEntries) -1; i >= 0; i -- {
			if rf.logEntries[i].Term == reply.ConflictTerm {
				rf.nextIndex[server] = i + 2
			}
		}
	}
		rf.nextIndex[server] = int(math.Max(float64(rf.nextIndex[server]), float64(1)))
		rf.mu.Unlock()
	}

è·å– AppendEntries å‚æ•°

	func (rf *Raft) getAppendEntriesArgsByServer(server int) ([]logEntry, int, int) {
		rf.mu.Lock()
		defer rf.mu.Unlock()
		nextIndex := rf.nextIndex[server]
		prevLogIndex := nextIndex - 1
		var logEntries []logEntry
		prevLogTerm := -1
		logEntries = rf.logEntries[prevLogIndex:]
		if prevLogIndex >= 1 {
			prevLogTerm = rf.logEntries[prevLogIndex-1].Term
		}
		return logEntries, prevLogIndex, prevLogTerm
	}

ä¸Šä¸€ç¯‡ raft ç¬”è®°ä¸­ *å®‰å…¨æ€§çº¦æŸ* ä¸­æåˆ°è®ºæ–‡ä¸­ figure8 æè¿°çš„å¤åˆ¶å‰ä»» leader æœª commit æ—¥å¿—çš„é—®é¢˜ã€‚æœ€åˆå®ç°çš„æ—¶å€™ï¼Œæˆ‘åœ¨ leader å‘èµ· appendEntries ä¹‹å‰éƒ½å…ˆåˆ¤æ–­ä¸‹ leader å°†è¦å‘é€ç»™ follower çš„æœ€åä¸€æ¡æ—¥å¿—çš„ term æ˜¯å¦ç­‰äºå½“å‰ leader çš„ termï¼Œå¦‚æœä¸ç›¸ç­‰åˆ™å°† args.Entries è®¾ç½®ä¸ºç©ºï¼Œä¸å‘é€æ—¥å¿—ã€‚ä½†æ˜¯è¿™æ ·æœ‰ä¸€ä¸ªé—®é¢˜ï¼šleader å½“é€‰ä¹‹åæœ‰ä¸€äº›å·²ç» commit çš„æ—¥å¿—æœ‰äº›èŠ‚ç‚¹è¿˜æ²¡æœ‰åŒæ­¥ï¼Œä½†æ˜¯ leader ä¸€ç›´ä¹Ÿæ²¡æœ‰æ”¶åˆ°æ¥è‡ªå®¢æˆ·ç«¯çš„æ–°æ—¥å¿—ï¼Œå¦‚æœæŒ‰ç…§ä¸Šè¿°å®ç°æ–¹å¼ï¼Œleader çš„è¿™äº›æ—¥å¿—ä¸€ç›´æ²¡åŠæ³•åŒæ­¥ç»™è¿™äº›èŠ‚ç‚¹ã€‚

å…·ä½“å®ç°æ–¹å¼æ˜¯åœ¨ leader å½“é€‰ä¹‹åç«‹å³å†™å…¥ä¸€ä¸ªå½“å‰ term çš„ no-op æ—¥å¿—ã€‚ä½†æ˜¯ 2B ä¸­çš„ä¸€äº› testcase æ˜¯æ£€æŸ¥æ—¥å¿— index çš„ï¼Œä¸€äº› testcase ä¼šå¤±è´¥ã€‚æˆ‘æ›¾ç»å°è¯•ä¸æŒ‰ç…§è®ºæ–‡ä¸­çš„æ–¹å¼è®©æ—¥å¿—çš„ index ä» 0 å¼€å§‹ï¼Œå…¶ä»– testcase ä¼šè¿‡ä½†æ˜¯ `TestFailNoAgree2B` case è¿˜æ˜¯ä¸ç¨³å®šï¼Œå› ä¸ºæ–°çš„ leader å½“é€‰ä¹‹åä¼šå†™ä¸€æ¡ç©ºæ—¥å¿—ï¼Œè¿˜æ˜¯ä¼šæ‰“ä¹±ä¹‹å‰ indexã€‚æœ€åæˆ‘ç´¢æ€§è¿˜æ˜¯ index ä» 1 å¼€å§‹ï¼Œå»æ‰äº†èŠ‚ç‚¹å½“é€‰ leader å†™å…¥ no-op æ—¥å¿—ã€‚æœ€åæ‰€æœ‰çš„ testcase ç¨³è¿‡ã€‚ï¼ˆæ€€ç–‘äººç”Ÿ... å†³å®šå…ˆæç½®ï¼Œç­‰ç©ºäº†å†ç ”ç©¶ä¸‹ `TestFigure82C` `TestUnreliableAgree2C`ï¼‰

### å‡ ä¸ªé‡è¦ç»†èŠ‚


#### **matchIndex and nextIndex**

matchIndex è®°å½•æ¯ä¸ª server å½“å‰æ—¥å¿—åŒæ­¥åˆ°äº†å“ªé‡Œã€‚æ‰€ä»¥æ¯æ¬¡èŠ‚ç‚¹æ—¥å¿—æ›´æ–°æˆåŠŸéƒ½éœ€è¦æ›´æ–° matchIndexï¼ŒåŒæ—¶æ›´æ–° nextIndex = matchIndex + 1

	func (rf * Raft) updateNextIndexAndMatchIndex(server int, matchIndex int) {
		rf.mu.Lock()
		defer rf.mu.Unlock()
		if matchIndex <= rf.matchIndex[server] {
			return
		}
		rf.matchIndex[server] = matchIndex
		rf.nextIndex[server] = rf.matchIndex[server] + 1
		return
	}
	
matchIndex æ˜¯ä¸€ä¸ªæœ€ç»ˆç»“æœï¼ŒnextIndex æ˜¯ä¸€ä¸ªä¸­é—´ç»“æœã€‚

å¦‚æœ follower åŒæ­¥æ—¥å¿—è¿”å›æˆåŠŸï¼Œåˆ™æ›´æ–°è¿™ä¸ª follower çš„ matchIndexï¼ŒmatchIndex = prevLogIndex + len(entries[])ï¼Œ nextIndex = matchIndex + 1ã€‚

å¦‚æœ follow åŒæ­¥æ—¥å¿—è¿”å›å¤±è´¥ï¼ˆä¸æ˜¯å› ä¸º term æ¯”å¯¹æ–¹å°å¯¼è‡´çš„å¤±è´¥ï¼‰ï¼Œåˆ™ä¸€ç›´ decrements nextIndexï¼Œç›´åˆ°åŒæ–¹æ—¥å¿—è¾¾åˆ°ä¸€ä¸ªåŒ¹é…çš„ç‚¹ã€‚

æˆ‘æœ€åˆå®ç°çš„ç‰ˆæœ¬æŒ‰ç…§è®ºæ–‡ä¸­å†™çš„æ¯æ¬¡æ—¥å¿—åŒ¹é…å¤±è´¥ nextIndex éƒ½å‡1ï¼Œä½†æ˜¯åœ¨è·‘ 2C Figure8 Unreliable çš„æ—¶å€™ä¸€ç›´æŠ¥ `Failed to reach agreement` é”™è¯¯ï¼ŒæŒ‰ç…§ `students' guide` æåŠçš„æ–¹æ³•ä¼˜åŒ–ï¼Œå‡å°‘ `rejected AppendEntries RPCs` çš„æ¬¡æ•°ã€‚

>If desired, the protocol can be optimized to reduce the
number of rejected AppendEntries RPCs. For example,
when rejecting an AppendEntries request, the follower can include the term of the conflicting entry and the first
index it stores for that term. With this information, the
leader can decrement nextIndex to bypass all of the conflicting entries in that term; one AppendEntries RPC will
be required for each term with conflicting entries, rather
than one RPC per entry. In practice, we doubt this optimization is necessary, since failures happen infrequently
and it is unlikely that there will be many inconsistent entries.

For follower 

>1. If a follower does not have prevLogIndex in its log, it should return with conflictIndex = len(log) and conflictTerm = None.
2. If a follower does have prevLogIndex in its log, but the term does not match, it should return conflictTerm = log[prevLogIndex].Term, and then search its log for the first index whose entry has term equal to conflictTerm.

For Leader 

Leader æ”¶åˆ° follower è¿”å›çš„ conflictTermï¼Œéœ€è¦åœ¨è‡ªå·±çš„æ—¥å¿—ä¸­æ‰¾åˆ°ä¸ conflictTerm ç›¸ç­‰çš„æœ€åä¸€æ¡æ—¥å¿—ï¼Œå°† nextIndex è®¾ç½®æˆè¿™æ¡æ—¥å¿—çš„ä¸‹ä¸€æ¡æ—¥å¿—çš„ indexã€‚ 

> 1. Upon receiving a conflict response, the leader should first search its log for conflictTerm. 
> 2. If it finds an entry in its log with that term, it should set nextIndex to be the one beyond the index of the last entry in that term in its log.
If it does not find an entry with that term, it should set nextIndex = conflictIndex.

å…¶å® leader å¯ä»¥ç›´æ¥è®¾ç½® nextIndex = conflictIndex, å¼•å…¥ ConflictTerm å¯ä»¥å‡å°‘éå¿…è¦çš„æ—¥å¿—åŒæ­¥ï¼š

> A half-way solution is to just use conflictIndex (and ignore conflictTerm), which simplifies the implementation, but then the leader will sometimes end up sending more log entries to the follower than is strictly necessary to bring them up to date.

<img src="/images/confilctIndex.png">

å¦‚æœä»…ä»…ç”¨ conflictIndex ä¸ç”¨ conflictTermã€‚ä¸Šå›¾ï¼Œæœ€å¼€å§‹ leader nextIndex = 9ï¼Œ prevLogIndex = 8ï¼ŒprevLogTerm = 3ï¼Œfollower æ”¶åˆ°æ—¥å¿—ï¼ŒconflictTerm = 2ï¼ŒconflictIndex = 3ã€‚å¦‚æœ leader æ”¶åˆ°å›å¤ä¹‹åä»…ä»…å°† nextIndex è®¾ç½®ä¸º 3ï¼Œä¼šå°† Index = [3, 4] ä¸¤æ¡ä¸å¿…è¦å‘é€çš„æ—¥å¿—ä¹Ÿå‘é€è¿‡å»ã€‚å¦‚æœæœ‰ conflictTerm = 2ï¼Œ nextIndex ä¸º 5ï¼Œé˜»æ­¢äº† index = [3, 4] ä¸¤æ¡ä¸å¿…è¦çš„æ—¥å¿—å‘é€ã€‚

matchIndex and nextIndex votes åˆå§‹åŒ–

	func (rf *Raft) becomeLeader() {
		lastLogIndex, _ := rf.getLastLogIndexAndTerm()
		rf.mu.Lock()
		rf.currentRole = Leader
		rf.nextIndex = make([]int, len(rf.peers))
		rf.matchIndex = make([]int, len(rf.peers))
		rf.votes = make(map[int]bool)
		for server, _ := range rf.peers {
			rf.nextIndex[server] = lastLogIndex + 1
		}
		rf.mu.Unlock()
		//rf.handleLogs("no-op")
		rf.persist()
	}


#### **CommitIndex**

**Leader**

Leader appendEntries æˆåŠŸè¿”å›ä¹‹åä¼šæ ¹æ® matchIndex æ¥æ›´æ–° commitIndexï¼šIf there exists an N such that N > commitIndex, a majority of matchIndex[i] â‰¥ N, and log[N].term == currentTerm: set commitIndex = Nã€‚å®ç°ä¸­å¯¹ matchIndex æŒ‰ä»é«˜åˆ°ä½æ’åºï¼Œå– index = majorityCount å¤„çš„ machINdex ä¸º commitIndexã€‚

	func (rf *Raft) updateLeaderCommitIndex() {
		majorityCount := rf.majorityCount()
		rf.mu.Lock()
		var sortedMatchIndex = make([]int, len(rf.matchIndex))
		copy(sortedMatchIndex, rf.matchIndex)
	sort.Slice(sortedMatchIndex, func(i, j int) bool {
		return sortedMatchIndex[i] > sortedMatchIndex[j]
	})
		majorityCommitIndex := sortedMatchIndex[majorityCount-1]
		if majorityCommitIndex > rf.commitIndex {
			rf.commitIndex = majorityCommitIndex
		}
		rf.mu.Unlock()
	}

**follower**

If leaderCommit > commitIndex, set commitIndex =
min(leaderCommit, index of last new entry)ã€‚Follower åœ¨ append æ—¥å¿—æˆåŠŸä¹‹åï¼š
	
	if reply.Success {
		index := int(math.Min(float64(args.LeaderCommit), float64(len(rf.logEntries))))
		if index > rf.commitIndex {
			rf.commitIndex = index
		}
	}
	
#### **when convert to follower**

>Ensure that you follow the second rule in â€œRules for Serversâ€ before handling an incoming RPC. The second rule states:
>>**If RPC request or response contains term T > currentTerm: set currentTerm = T, convert to follower (Â§5.1)**

>For example, if you have already voted in the current term, and an incoming RequestVote RPC has a higher term that you, you should first step down and adopt their term (thereby resetting votedFor), and then handle the RPC, which will result in you granting the vote!

æœ‰å››å¤„åœ°æ–¹éœ€è¦åˆ¤æ–­æ˜¯å¦éœ€è¦ convertToFollowerï¼š1. å‘èµ·æŠ•ç¥¨æ”¶åˆ°å“åº”ä¹‹å; 2. requestVote handler ï¼›3. Leader å‘é€ appendEntries æ”¶åˆ°å“åº”ä¹‹åï¼›4. appendEntries handlerã€‚**before handling an incoming RPC** è¿™ç‚¹å¾ˆé‡è¦ï¼

	func (rf *Raft) convertToFollowerOrNot(term int, server int) {
		rf.mu.Lock()
		if term > rf.currentTerm {
			rf.currentRole = Follower
			rf.currentTerm = term
			rf.votedFor = -1
		}
		rf.mu.Unlock()
		rf.persist()
	}

#### **Reset electionTimer**

> Make sure you reset your election timer exactly when Figure 2 says you should. Specifically, you should only restart your election timer if a) you get an AppendEntries RPC from the current leader (i.e., if the term in the AppendEntries arguments is outdated, you should not reset your timer); b) you are starting an election; or c) you grant a vote to another peer

é‡ç½® electionTimer æ—¶æœºï¼š

 1. å‘èµ·é€‰ä¸¾ä¹‹å 
 2. requestVote hander ç»™æŸä½ candidate æŠ•ç¥¨ä¹‹å
 3. appendEntries handler åœ¨åˆ¤æ–­ convertToFollower ä¹‹å


	func (rf *Raft) resetElectionTimer() {
		rf.mu.Lock()
		rf.electionTimeout = rf.getElectionTimeout()
		rf.heartbeatTimestamp = rf.getCurrentMillTimeStamp()
		rf.mu.Unlock()
	}

### æŒä¹…åŒ–

currentTerm votedFor log[] è¿™å‡ ä¸ªå‚æ•°æ˜¯éœ€è¦æŒä¹…åŒ–çš„æ•°æ®ï¼Œæ‰€ä»¥åªéœ€è¦åœ¨è¿™äº›å‚æ•°æœ‰å¯èƒ½å‘ç”Ÿå˜åŒ–çš„æ—¶å€™è°ƒç”¨ rf.persist() å³å¯ã€‚
ç”±äº commitIndex å’Œ nextIndex æ˜¯æ˜“å¤±çš„æ•°æ®ï¼Œåœ¨æŸä¸ªèŠ‚ç‚¹å½“é€‰ä¸º leader ä¹‹åï¼ŒcommitIndex lastApplied éƒ½é‡æ–°åˆå§‹åŒ–ï¼Œè¿™æ ·ä¼šå¯¼è‡´èŠ‚ç‚¹çš„æ—¥å¿—ä¼šé‡å¤ applyã€‚

**LogEntries**

It is the only record of the application
w state. When the server restarts the only information available to reconstruct the application state is the sequence of commands in the log

**CurrentTerm**

è®°å½•æ—¥å¿—æ—¶éœ€è¦è®°å½•å½“å‰æ—¥å¿—çš„ termã€‚
å‘èµ·æŠ•ç¥¨çš„æ—¶å€™éœ€è¦æ¯”è¾ƒä¸¤è€…çš„ termã€‚
æŸä¸ª term ä¸‹åªèƒ½æœ‰ 1 ä¸ª leaderã€‚

**votedFor**

å‡è®¾ä¸€ä¸ªèŠ‚ç‚¹åœ¨æ”¶åˆ°å¦ä¸€ä¸ªèŠ‚ç‚¹çš„æŠ•ç¥¨è¯·æ±‚æŠŠç¥¨æŠ•ç»™äº†ä»–ä¹‹åæŒ‚æ‰äº†ã€‚å¦‚æœå®ƒæ²¡æœ‰æŒä¹…åŒ– votedForï¼Œæ¥ç€å®ƒæ¢å¤äº†ï¼Œåˆæ”¶åˆ°æ¥è‡ªå¦ä¸€ä¸ªèŠ‚ç‚¹çš„æŠ•ç¥¨è¯·æ±‚å½“å‰ votedFor æ˜¯ç©ºï¼Œæ¥ç€ç»™è¿™ä¸ªèŠ‚ç‚¹æŠ•äº†ç¥¨ã€‚è¿™ä¸ªæ—¶å€™ä¸¤ä¸ªèŠ‚ç‚¹éƒ½è®¤ä¸ºè‡ªå·±æ”¶åˆ°äº† majority çš„æŠ•ç¥¨è¯·æ±‚ï¼Œè¿™æ ·å°±åŒæ—¶æœ‰ä¸¤ä¸ªèŠ‚ç‚¹æˆä¸º leaderã€‚

**Volatile State: commitIndex lastApplied nextIndex matchIndex**

Leader å¯ä»¥é€šè¿‡è‡ªå·±æœ¬åœ°æ—¥å¿—å’Œå¾€ follower å‘é€ appendEntries æ¥åˆ¤æ–­å‡ºå½“å‰ commitIndex å’Œ lastApplied nextIndex matchIndexï¼Œfollower åœ¨æ”¶åˆ° leader çš„ appendEntries ä¹‹åå¯ä»¥é€šè¿‡ leader çš„ commitIndex å’Œ æœ¬åœ°æ—¥å¿—æ¥è®¡ç®—å‡ºè‡ªå·±çš„ commitIndexã€‚è¿™æ ·å¯¼è‡´é—®é¢˜æ˜¯ leader å’Œ follower æœ‰å¯èƒ½é‡å¤ apply æ•°æ®ã€‚

é‡ç°æ—¥å¿—çš„è¿‡ç¨‹ä¼šå¾ˆæ…¢ï¼Œæ‰€ä»¥ raft å¼•å…¥äº† snapshot


æœ€åè´´ä¸ªå›¾ 
<img src="/images/mit6.824.png">
