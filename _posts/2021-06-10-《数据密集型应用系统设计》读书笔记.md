---
layout: post
title: "《数据密集型应用系统设计》读书笔记"
---
# 数据系统基础
## 可靠、可扩展与可维护的应用系统

### 认识数据系统

设计数据系统和数据服务时，一定会碰到很多棘手的问题。例如，当系统内出现了局部失效时，如何确保数据的正确性和完整性？当发生系统降级时，如何为客户提供一致的良好表现？负载增加时，系统如何扩展？友好的服务API该如何设计？

### 可靠性

即使发生了某些错误，系统仍可以继续正常工作。
我们不太可能将故障概率降低为0，因此通常设计容错机制来避免从故障引发系统失效。

**硬件故障**

为硬件添加冗余来减少系统故障率。
只要可以将备份迅速恢复到新机器上，故障的停机时间大多数应用中并不是灾难性的。多机冗余则只对少量的关键应用更有意义，对于这些应用，高可用是绝对必要的。

**软件错误**

软件系统问题有时没有快速解决办法，而只能仔细考虑很多细节，包括认真检查依赖的假设条件与系统之间交互，进行全面的测试，进程隔离，允许进程崩溃并自动重启，反复评估，监控并分析生产环节的行为表现等。

**人为失误**

* 以最小出错的方式来设计系统。如：精心设计的抽象层，使“做正确的事情”很轻松，但搞坏很复杂。如果限制过多，人们会想办法绕过，解决之道在于很好的平衡
* 分离最容易出错的地方。提供一个功能齐全的沙箱环境，必要时导入线上真实数据，在里面放心的尝试体验，万一出现问题不会影响真实用户
* 充分测试
* 详细而清晰的监控子系统
* 推行管理流程并加以培训

### 可扩展性
 
如果系统以某种方式增长，我们应对增长的措施有哪些？我们该如何添加计算资源来处理额外的负载？

**描述负载** 

负载可以用称为负载参数的若干数字来描述。参数的最佳选择取决于系统的体系结构，它可能是 web 服务器每秒请求处理次数，数据库的写入比例，聊天室同时活动用户数量，缓存命中率等。

以 twitter 为例，两个典型的业务场景：

* 用户发布 twitter，将 twitter 推送到所有的关注者，4.6 request/sec 峰值 12k requests/sec
* home timeline，关注者查看关注对象的最新消息，平均 300k requests/sec

有两种处理方案：

1. users 表 + follows 表 + tweets 表；用户发布 tweets 插入到 tweets 表、follows 表存储用户关注关系；当某一个用户查看 timeline 时，查找所有的关注对象列出这些人所有的 tweets，最后以时间为序来排序:

> select tweets.* , users.* from  tweets 
	join users on tweets.sender_id = users.id
	join follows on follows.followee_id = users.id
	where users.follower_id = current_user

2. 对每个用户的 timeline 维护一个缓存，当用户推送新 tweet 时，查询所有的关注者，将 tweet 插入到其所有关注则的 timeline 的缓存中。因为 timeline 的浏览压力比发布 tweet 要高出两个数量级，在发布时多完成一些事情可以加速读性能。

方法2的缺点，考虑到平均 75 个关注者，每秒 4.6 k的 tweet，需要每秒 4.6k * 75 = 345k 的速率写入缓存。关注者偏差大，如果某人有 3k万的 follower 峰值一个 tweet 会有 3k万的写入。优化方案：少数有超多关注者的用户 tweet 单独提取采用类似 1 的方式，在读取时和用户的 timeline 进行合并。

**描述性能**

设想如果负载增加将会发生什么？有两种考虑方式：

* 负载增加，但系统资源（如 CPU 内存 网络带宽等）保持不变，系统性能会发生什么变化？
* 负载增加，如果要保持性能不变，需要增加多少资源

**应对负载增加的方法**

水平扩展和垂直扩展。
好的架构通常要做些实际的取舍，例如，使用几个强悍的服务器仍可以比大量的小型虚拟机来得更简单、便宜。

超大规模的系统往往针对特定的应用高度定制，很难有一种通用的架构。背后的取舍因素包括读取量、写入量、待存储的数据量、数据的复杂度、响应时间要求、访问模式等，更多的是上述所有因素的叠加再加上其他更复杂的问题。

对于早期初创公司或未定型的产品，快速迭代退出产品功能往往比投入精力来应对不可知的扩展性更为重要。

### 可维护性

每一个遗留系统总有其过期的理由，所以很难给出一个通用的建议该如何处理它们。

我们可以在软件设计时考虑尽可能减少维护期间的麻烦，避免造出荣有过期的系统。

软件系统的三个设计原则：

* 可维护性 方便运维团队保持系统平稳运行
* 简单性 简化系统复杂性 新工程师可以轻松理解系统
* 可演化性 后续工程师可以轻松的对系统进行改进，并根据需求变化将其适配到非典型场景，

**可运维性**

一个优秀的运行团队负责的内容

数据系统设计可以贡献的：

* 提供监控
* 支持自动化 与标准工具集成
* 避免绑定具体的机器 
* 提供良好的文档和易于理解的操作模式
* 提供良好的默认配置允许管理员需要时方便的修改默认值
* 尝试自我修复 需要时让管理员手动控制系统状态
* 行为可预测 减少意外发生

**简单性：简化复杂度**

复杂性有各种各样的表现形式：状态空间的膨胀，模块紧耦合，令人纠结的相互依赖关系，不一致的命名和术语，为了性能而采取的特殊处理，为解决某特定问题而引入的特殊框架等。

消除意外复杂性的最好的手段之一是抽象。一个好的设计抽象可以隐藏大量的实现细节，并对外提供干净、易懂的接口。

**可演化性 易于改变**

简单易懂的系统往往比复杂的系统更容易修改。


## 数据模型与查询语言

大多数应用程序是通过一层一层叠加数据模型来构建的。每一层都面临的关键问题是：如何将其用下一层表示？例如：

1. 应用程序开发人员，观测现实世界，通过对象或数据结构以及操作这些数据结构的 api 对其进行建模。这些数据结构往往特定于该应用。
2. 当需要存储这些数据结构时，可以采用通用数据模型来表示
3. 数据库工程师接着决定用何种内存 磁盘或网络字节格式来表示上述 json/xml/关系/图形数据。数据需要支持多种方式的查询 搜索 操作和处理数据
4. 在更下一层，硬件工程师则需要考虑用电流 光脉冲 磁场等来表示字节

每层都通过提供一个简洁的数据模型来隐藏下层的复杂性。

考虑到数据模型对其上的软件应用有着巨大的影响（哪些能做哪些不能），因此需要慎重选择合适的数据模型。


问题：

* 在描述性能那块，服务器并行处理的请求有限（cpu 核数），正在处理的少数请求可能会阻挡后续请求，队头阻塞

	



 


