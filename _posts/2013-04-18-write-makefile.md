---
layout: post
title: "Write Makefile"
description: ""
category: linux
tags: [GNU tools]
---
{% include JB/setup %}

**Why We Need to Use Make:**

Though IDE and language-specific compiler features can also be used to manage a build process , Make remains widely used expecially in Unix.To build a very large program you need an extended set of invocations to to the 'gcc' compiler and utilities like 'ar','ranlib'.It is not necessary to rebuild the object everything if you make changes only to a few files in your source code.The 'make'utility was written mainly to automate rebuilding software by determaining the minmum set of commands taht need to be called do this and invoking them for you in the right order.   
In GNU bulid systems,you can just use [automake](http://en.wikipedia.org/wiki/Automake) to produces portable makefiles for use by make program. But it is also necessary to know how to write makefile.

**The relationship between Make and Makefile:**

'Make' makes you to complier and recompiler your source code easily.GNU make does its work in two distinct phases. During the first phase it reads all the makefiles, included makefiles, etc. and internalizes all the variables and their values, implicit and explicit rules, and constructs a dependency graph of all the targets and their prerequisites. During the second phase, make uses these internal structures to determine what targets will need to be rebuilt and to invoke the rules necessary to do .'Make' itself has no knowledge about the synax of the files taht it works with,it relies on the files instuction in 'makefile' to figure out what it needs to do such as automatically to build executable programs and libraries frome source by reading files called [makefiles],so we should know how to write makefile.

<!---  编译链接装载与库* Since makefile makes us compile our code easily, let's discuss how to compile C source code just by gcc.
   If you have a file called `hello.c`,you just type `GCC hello.c -o hello` on your shell.And it will produce a executable file called hello.and you can run it in your shell like this:`./hello`.

  What you should do if you have a much larger program made of source files:`foo1.c` `foo2.c` `foo3.c` and header files `header1.h` and `header2.h`.One way to compile the program is like this:`gcc foo1.c foo2.c foo3.c -o foo`.If you have dozen files , you must compile every file just because one file have changed.So you can do in this way:
<pre class="pre-color">
$gcc foo1.c
$gcc foo2.c
$gcc foo3.c #compile all the three .C file 
$gcc foo1.o foo2.o foo3.o -o foo #link them to final executable file foo
</pre>
  [.o](http://stackoverflow.com/questions/2186246/what-is-o-file) file is an object file ,the compiler creates an object file for each source file, before linking them together, into the final executable (for example *hello and * foo).
[For more informatio GNU make manual](http://www.gnu.org/software/make/manual/html_node/)
 --->

** Basic rule of Makefile:**
  

      target: dependences
      #target is the name of a file that is generated by a program (example:object file or executable file)or the name of an action to carry out (here target is called phony target) (exanple cleaning up the object files)
      #Ofen dependence is a file that is used as input to create a target.If a target has more than one dependence,they must be separated by space,but they must remain on the same line.Target also may have no dependence, so after semicolon is blank.A target can also dependent for another target.
      tab command            #If a target is an action ,the command describe it 
      tab .......            #If the target is file ,the command explain how to create it
      tab .......            #TAB are mandatory
      [BLANK LINE]          
      #blank line is not necessary but it is good idea if you would lik backwords compatibility with Unix
The simpilest makefile:

     hello: hello.o
     TAB gcc -o hello hello.c

     hello.o: hello.c
     TAB gcc -c hello.c
     clean:            #t his is an action have no dependence
     TAB rm -rf hello hello.o

     install: hello               #make sure that we have file "hello" first
     TAB mkdir -p /usr/local/bin  #usually we all have it in our os (no need) but it is also necessary 
     TAB rm -rf /usr/local/bin/hello
     TAB cp hello /usr/local/bin/hello

But makefile has lots of redundancy: we may have more file like: *.o or *.c ... So it is necessary for us  to use Makefile  variables and abstract rules:`variables=value`,the symbol`$`(variables) is substitude with value.Here is some explain:

      "Build '*.o' (corresponded generated file) from '*.c' (source file)"
      .c.o:
      #Note:No dependence cause it don't make sense in general case.There is no need to indicate dependent file explicitly
      TAB gcc -c $<  
      #`$<` are the dependencies that changed causing the target to need to rebuild  ...?

      "Build exectable file from object file"
      .o:
      TAB gcc $^ -o $@ 
      #`$@` is the target `$^` are all dependencies for the current rule

Our makefile like this:

      CC=gcc
      CFLAGS=-Wall -g
      OBJECTS=foo1.o f002.o foo3.o foo4.o
      PREFIX=/usr/local

      .SUFFIX:.c .o
      # Note: Objectable file don't have suffix so we mention it in objectable file
      .c.o:
      TAB $(CC) $(CFLAGS) -c $<

      .o:
      TAB $(CC) $(CFLAGS) $^ -o $@

      foo:$(OBJECTS)
      foo1.o:foo1.c gleep2.h gleep3.h
      foo2.o:foo2.c gleep1.h
      foo3.o:foo3.c gleep1.h gleep2.h
      foo4.o:foo4.c gleep3.h
      #'Make' does't know C source code and it's dependence ,so we have to write it by ourselves
      #But we can use '$ gcc -MM file.c' to find out the dependent of "file.c'

      clean:
      TAB rm -f $(OBJECTS)

      install: foo
      TAB mkdir -p $(PREFIX)/bin
      TAB rm -f $(PREFIX)/bin/foo
      TAB cp foo $(PREFIX)/bin/foo

Equal to this :

      foo: foo1.o foo2.o foo3.o foo4.o
      TAB gcc -o foo foo1.o foo2.o foo3.o foo4.o

      foo1.o:foo1.c gleep2.h gleep3.h
      TAB gcc -c foo1.c

      foo2.o:foo2.c gleep1.h
      TAB gcc -c foo2.c

      foo3.o:foo3.c gleep1.h gleep2.h
      TAB gcc -c foo3.c

      foo4.o:foo4.c gleep3.h
      TAB gcc -c foo4.c

      clean:
      TAB rm -f foo foo1.o foo2.o foo3.o foo4.o

      install: foo
      TAB mkdir -p /usr/local/bin
      TAB rm -f /usr/local/bin/foo
      TAB cp foo /usr/localh/bin/foo


Here I will inturduce something about how to use GNU build system (also called autotools) to produce makefile . It is very simpile.We can use [Automake](http://www.gnu.org/software/automake/manual/automake.html).We can only write 'Makefile.am' and the file is then compiled into an intermediate file:'Makefile.in',by Automake and during installation the final file 'Makefile' is generated from 'Makefile.in' by a shellscript call [configure](http://www.nondot.org/sabre/Mirrored/autoconf-2.12/autoconf_2.html).

**Reference:**

[《跟我一起写Makefile》](http://blog.csdn.net/haoel/article/details/2886)


